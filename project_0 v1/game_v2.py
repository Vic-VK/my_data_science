import numpy as np
def random_predict(number:int=np.random.randint(1, 101)) -> int: # функция определяет количество попыток
    
    """ Рандомно/случайно угадываем число
    Args:
    number(int, optional): Загаданное число. Defaults to (1,100).
    
    Returns:
    int: Число попыток
    """
    count=0 # переменнная счетчик/количество попыток
    predict_number, min, max = 0, 1, 100   # объявляем переменные, объявляем predict_number, чтобы избежать ошибки, UnboundLocalError (что на переменную цикла ссылаются перед её назначением). Присваеваем ей значение не входящий в диапазон вероятного нахождения загаданного числа, чтобы не повлиять на чистату попыток. Так же можно оставить predict_number = int(np.random.randint(min, max + 1)), но тогда попытку надо засчитывать, и в этом случае count=1
    
    while  predict_number != number: # цикл, который подсчитывает попытки и предполагает числа до тех пор пока число не будет угадано
        count+=1
        predict_number = round((min + max)/2) # угадываем предполагаемое число, строя предположение, что загаданное число середина интервала (методом средней арифметической функции)
        #predict_number = round((((min)**2 + (max)**2)/2)**(1/2)) # диапазон итераций уже, чем ближе к искомому значению (методом средней квадратичной функции).
        if predict_number > number: # если предполагаемое число больше загаданного,
            max = predict_number # то уменьшаем вероятный диапазон, путём назначения новой максимальной (max) крайней точки интервала вероятного нахождения загаданного числа
        elif predict_number < number: # иначе предполагаемое число меньше загадонного
            min = predict_number # и, тогда вероятный диапазон сужается, и назначаем новое минимальное (min) значение крайней точки интервала вероятного нахождения загаданного числа
        if min == number: # вводим условие прекращение цикла, когда загаданное число равно нижнему/минимальному (min) значению крайней точки интервала вероятного нахождения загадонного числа
            break # конец цикла, в связи с невозможностью угадать предполагаемое числа из-за округления. Если используем round, то не угадаем самый минимальный предел, так как при делении 3/2 получаем округление до 2 (так же можно удленить диапозон min и max не от 1, а от 0 до 100, но тогда диапазон загадывания должен остаться прежним от 1 до 100). 
                  #в случае, если использовать оператор целочисленного деления (//), тогда надо вводить условие прекращения цикла для верхнего/максимального (max) значения крайней точки интервала вероятного нахождения загадонного числа (в связи с взятием целого числа, т.е. будет браться целое число от деление - 99)
    return (count)# конец игры, выход из цикла, если угодали
    
#print(f'Количество попыток: {random_predict()}')

def score_game(random_predict) -> int: #определяет среднее значение попыток при угадывании 1000 чисел функцией/алгоритмом random_predict(number)
    """За какое количество попыток в среднем из 1000 подходов угадывает наш алгоритм

    Args:
        random_predict ([type]): функция угадования

    Returns:
        int: среднее количество попыток
    """
    
    count_ls = [] #список для сохранения количества попыток
    np.random.seed() #если в random.seed(1) указан аргумент значит фиксируем значение для одинакового получения/генерации случайных чисел (воспроизведение чисел не зависимо от компьютера и в любое время), иначе  random.seed() - по умолчанию генератор использует текущее системное время и получаются разные значения (нефиксированные).
    random_array=np.random.randint(1,101, size=(1000)) #загадали список чисел
    for number in random_array: #цикл для создания списка количества попыток угадывания числа
        count_ls.append(random_predict(number))
        
    score = int(np.mean(count_ls)) # находим среднее количество попыток
    
    print(f'Ваш алгоритм угадывает число в среднем за: {score} попыток')
    return (score)




if __name__=='__main__':
    #RUN
    score_game(random_predict)